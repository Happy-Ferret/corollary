use std::str::FromStr;
use ast::*;
use lalrpop_util::ErrorRecovery;
use decode_literal;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, (usize, &'input str), ()>>);

pub Exprs = Comma<Expr>;

// A bunch of macros.

Dot<T>: Vec<T> = {
    <v:(<T> ".")+> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

Semi<T>: Vec<T> = {
    <v:(<T> ";")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Commaish<T>: Vec<T> = {
    <(<T> ","?)+> => <>,
};

CommaDef<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    },
};

Pipe<T>: Vec<T> = {
    <v:(<T> "|")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

// Common patterns.

Quote: String = {
    r#""[^"]*""# => {
      let a = <>;
      a[1..a.len()-1].to_string()
    }
};

SingleQuote: String = {
    r"'[^']*'" => {
      let a = <>;
      a[1..a.len()-1].to_string()
    }
};

Num: isize = {
    r"[0-9]+" => isize::from_str(<>).unwrap()
};

Ident: Ident = {
  r"[a-zA-Z_.][.a-zA-Z_0-9':]*(:[.+/*=-]+)?" => Ident((<>).to_string()),
};

Ctor: Ident = {
    r":[!#$%&*+./<=>?@^|~:\\-]*" => Ident(<>.to_string()),
};

Operator: String = {
    r"[!#$%&*+/<=>?@^|~][!#$%&*+./<=>?@^|~:\\-]*" => <>.to_string(),
    "." => <>.to_string(),
    ".." => <>.to_string(),
    ".|." => <>.to_string(),
    ".&." => <>.to_string(),
    "-" => <>.to_string(),
};

// Code structures

Case: CaseCond = {
    // TODO commas can be used in expr spans, see AST.hs
    <d:PatList> <v:("|" <CommaDef<ExprSpan>> "->" <ExprSpan>)*> => CaseCond::Matching(d, v),
    <d:PatList> "->" <v:CommaDef<ExprSpan>> ("where" "{" Semi<Statement> "}")? => CaseCond::Direct(d, v),
    "where" "{" <Semi<Statement>> "}" => CaseCond::Where,
};

ExprSpan: Expr = {
    <Expr+> => Expr::Span(<>),
};

Expr: Expr = {
    Quote => Expr::Str(decode_literal(&<>)),
    SingleQuote => Expr::Char(decode_literal(&<>)),
    Num => Expr::Number(<>),

    <Ident> => Expr::Ref(<>),
    <Ctor> => Expr::Operator(<>.0),
    <Operator> => Expr::Operator(<>),

    r"\\" Ident Expr* "->" Expr => Expr::Lambda,
    r"\\" "(" CommaDef<ExprSpan> ")" "->" Expr => Expr::Lambda,

    "[" <CommaDef<ExprSpan>> "|" CommaDef<ExprSpan> "]" => Expr::Dummy,
    "[" <CommaDef<ExprSpan>> ("::" PatSpan)? "]" => Expr::Vector(<>),
    "[" "]" => Expr::Vector(vec![]),
    "(" <CommaDef<(<ExprSpan> ("::" PatSpan)?)>>  ")" => Expr::Parens(<>),
    "(" ")" => Expr::Parens(vec![]),
    "(" "," ")" => Expr::Dummy,
    "(" Ident "->" PatList ")" => Expr::Dummy,

    "`" <Ident> "`" => Expr::Operator(<>.0),
    "!" => Expr::Operator(<>.to_string()),
    r"\\\\" => Expr::Operator(<>.to_string()),

    "case" <e:ExprSpan> "of" "{" <s:Semi<Case>> "}" => Expr::Case(Box::new(e), s),
    "let" "{" Semi<StatementWhere> "}" => Expr::Let,
    "do" "{" <e:Semi<StatementWhere>> "}" => Expr::Do(vec![], None),
    "{" "}" => Expr::Record(vec![]),
    "{" <r:CommaDef<(<Ident> "=" <ExprSpan>)>> ";"? "}" => Expr::Record(r),
};

// TODO Why is "where"" needed for end of do and let statements but is special cased elsewhere
StatementWhere: Statement = {
    <Statement> => <>,
    "where" "{" Semi<Statement> "}" => Statement::Dummy,
};

SContext: () = {
  Ident+ "=>" => (),
  "(" CommaDef<Ident+> ")" "=>" => (),
};

Statement: Statement = {
  "import" ImportList+ => Statement::Import,

  "type" <d:Ident> <args:TypeGroup?> "=" TypeGroup
    ("where" "{" Semi<Statement> "}")? => Statement::Dummy,
  "data" <id:Ident> =>
      Statement::Data(id, vec![], vec![]),
  "data" <id:Ident> <args:TypeGroup?> "=" <p:Pipe<TypeGroup>>
    <derives:("deriving" <ImportList>)?> =>
      Statement::Data(id, p, derives.unwrap_or(vec![])),
  "newtype" SContext? <id:Ident+> "=" <p:Type>
    <derives:("deriving" <ImportList>)?> =>
      Statement::Newtype(id[0].clone(), p, derives.unwrap_or(vec![])),
  "class" SContext? Ident+
    "where" "{" Semi<Statement> "}" => Statement::Class,
  "instance" TypeGroup
    "where" "{" Semi<Statement> "}" => Statement::Instance,

  // TODO left expr should be PatSpans
  <CommaDef<ExprSpan>> ("::" TypeGroup) => Statement::Dummy,
  <CommaDef<ExprSpan>> "=" <ExprSpan>
    ("where" "{" Semi<Statement> "}")? => Statement::Dummy,
  <ExprSpan> ("|" CommaDef<ExprSpan> "=" <ExprSpan>)+ ("where" "{" Semi<Statement> "}")? => Statement::Dummy,
  <ExprSpan> ("where" "{" Semi<Statement> "}")? => Statement::Dummy,
};

TypeRecord: () = {
  <Ident> "::" <TypeGroup> => (),
};

TypeSub: Ty = {
    "!" <TypeSub> => Ty::Not(Box::new(<>)),
    "[" <Type> "]" => Ty::Brackets(Box::new(<>)),
    "(" <CommaDef<Type>> ")" => Ty::Tuple(<>),
    "(" ")" => Ty::EmptyParen,
    "{" "}" => Ty::RecordTODO,
    "{" <CommaDef<TypeRecord>> "}" => Ty::RecordTODO,
    <Ident> => Ty::Ref(<>),
    <Ctor> => Ty::Ref(<>),
};

TypeSpan: Ty = {
    <TypeSub+> => Ty::Span(<>),
};

Type: Ty = {
    <a:TypeSpan> "->" <b:Type> => Ty::Pair(Box::new(a), Box::new(b)),
    <TypeSpan> => <>,
};

TypeGroupInner: Ty = {
  <a:TypeSub> "=>" <b:TypeGroupInner> => b,
  <a:TypeSub> "->" <b:TypeGroupInner> => b,
  <TypeSub> => <>,
};

TypeGroup: Vec<Ty> = {
    <TypeGroupInner+> => <>,
};

PatSub: Pat = {
    "!" <PatSub> => Pat::Not(Box::new(<>)),
    "[" <CommaDef<PatSpan>> "]" => Pat::Brackets(<>),
    "[" "]" => Pat::Brackets(vec![]),
    "(" <PatSpan> ")" => <>,
    "(" <h:PatSpan> "," <t:CommaDef<PatSpan>> ")" => {
        let mut vec = vec![h];
        vec.extend_from_slice(&t);
        Pat::Tuple(vec)
    },
    "(" <i:Ident> "->" <s: PatSpan> ")" => Pat::Arrow(i, Box::new(s)),
    "(" ")" => Pat::EmptyParen,
    "{" "}" => Pat::RecordTODO,
    "{" <CommaDef<PatRecord>> "}" => Pat::RecordTODO,

    <Ident> => Pat::Ref(<>),
    <Ctor> => Pat::Ref(<>),
    <Operator> => Pat::Ref(Ident(<>)),
    <Quote> => Pat::Str(decode_literal(&<>)),
    <SingleQuote> => Pat::Char(decode_literal(&<>)),
    <Num> => Pat::Num(<>),

    // HACK
    "`" Ident "`" => Pat::Dummy,
};

PatRecord: () = {
  <Ident> "=" <PatSpan> => (),
  ".." => (), // RecordWildCards
};

// for matching (Ctor arg arg ...)
PatSpan: Pat = {
    <PatList> => Pat::Span(<>),
};

// for matching e.g. multiple function args
PatList: Vec<Pat> = {
    <PatSub+> => <>,
};

ImportName: () = {
  Ident => (),
  ".." => (),
};

ImportList: Vec<Ident> = {
    "(" <a:Commaish<(<Ident> ("(" ImportName ")")?)>> ")" => a,
    "(" ")" => vec![],
    <Ident> => vec![<>],

    "(" "(<|>)" ")" => vec![], // ??? see DefTable.hs
};

Section: () = {
    Ident ("(" ".." ")")? => (),
    Ident "(" Ident* ")" => (),
    "module" Ident ("(" CommaDef<Section> ")")? => (),
};

pub Module: Module = {
  "module" <n:Ident> ("(" Comma<Section> ")")?
    "where" "{" <s:Semi<Statement>> "}" => Module {
      name: n,
      statements: s,
    },
};
