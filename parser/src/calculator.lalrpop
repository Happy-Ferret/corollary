use std::str::FromStr;
use ast::*;
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, (usize, &'input str), ()>>);

pub Exprs = Comma<Expr>;

Dot<T>: Vec<T> = { // (0)
    <v:(<T> ".")+> <e:T> => { // (1)
        let mut v = v;
        v.push(e);
        v
    }
};

Semi<T>: Vec<T> = { // (0)
    <v:(<T> ";")*> <e:T?> => match e { // (1)
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Comma<T>: Vec<T> = { // (0)
    <v:(<T> ",")*> <e:T?> => match e { // (1)
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Pipe<T>: Vec<T> = { // (0)
    <v:(<T> "|")*> <e:T?> => match e { // (1)
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Commaish<T>: Vec<T> = { // (0)
    <(<T> ","?)+> => <>,
};

CommaDef<T>: Vec<T> = { // (0)
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    },
};


Ident: Ident = {
  r"[a-zA-Z_.][.a-zA-Z_0-9']*" => Ident((<>).to_string()),
};

Section: i32 = {
    Ident ("(" ".." ")")? => 0,
    Ident "(" Ident* ")" => 0,
    "module" Ident ("(" Comma<Section> ")")? => 0,
};

Case: () = {
    Destructure+ ("|" Commaish<Expr> "->" Expr+)* => (),
    Destructure+ "->" Expr+ => (),
};

Quote: () = {
    //r#"'\\["]'"# => (),
    r#"'[^']'"# => (),
    r#""[^"]*""# => (),
};

Expr: Expr = {
    Quote => Expr::Dummy,
    <Ident> => Expr::Ref(<>),
    "\(" Commaish<Ident> ")" "->" Expr => Expr::Dummy,
    "[" <Commaish<Expr>> "|" Expr+ "]" => Expr::Dummy,
    "[" <Commaish<Expr>> "]" => Expr::Parens(<>),
    "[" "]" => Expr::Parens(vec![]),
    "(" <Commaish<Expr>> ")" => Expr::Parens(<>),
    "(" ")" => Expr::Parens(vec![]),
    "(" "," ")" => Expr::Dummy,
    "(" Ident "->" Type ")" => Expr::Dummy,

    r"\\[a-zA-Z_.][.a-zA-Z_0-9']*" Expr* "->" Expr => Expr::Dummy,
    r"[0-9]+" => Expr::Dummy,

    "\\" => Expr::Dummy,
    "`" Ident "`" => Expr::Dummy,
    ":" => Expr::Dummy,
    "." => Expr::Dummy,
    "/=" => Expr::Dummy,
    "==" => Expr::Dummy,
    ".." => Expr::Dummy,
    "++" => Expr::Dummy,
    "$" => Expr::Dummy,
    "&&" => Expr::Dummy,
    "||" => Expr::Dummy,
    "<" => Expr::Dummy,
    "<=" => Expr::Dummy,
    "<-" => Expr::Dummy,
    ">" => Expr::Dummy,
    ">=" => Expr::Dummy,
    "=<<" => Expr::Dummy,
    ".|." => Expr::Dummy,
    ">>=" => Expr::Dummy,
    "@" => Expr::Dummy,
    "*" => Expr::Dummy,
    "+" => Expr::Dummy,
    "-" => Expr::Dummy,
    "^" => Expr::Dummy,
    "::" => Expr::Dummy,
    ".&." => Expr::Dummy,

    "case" Expr+ "of" "{" Semi<Case> "}" => Expr::Dummy,
    "let" "{" Semi<Statement> "}" => Expr::Dummy,

    "do" "{" <e:Semi<Expr+>>
    <w:("where" "{" <Semi<Statement>> "}")?> "}" => Expr::Do(e, w),
    "{" Comma<(Ident "=" Expr+)> "}" => Expr::Dummy,
};

FnDef: Ty = {
    //<a:Type> "=>" <b:Type> => Ty::Where(Box::new(a), Box::new(b)),

    <a:Type> "=>" <b:Type> => b,
    <Type> => <>,
};

Type: Ty = {
    <a:TypeSpan> "->" <b:Type> => Ty::Pair(Box::new(a), Box::new(b)),
    <TypeSpan> => <>,
};

TypeSub: Ty = {
    "!" <Ident> => Ty::Not(Box::new(Ty::Ref(<>))),
    "[" <CommaDef<TypeSpan>> "]" => Ty::Brackets(<>),
    "(" <CommaDef<TypeSpan>> ")" => Ty::Parens(<>),
    "(" ")" => Ty::EmptyParen,
    <Ident> => Ty::Ref(<>),
};

TypeSpan: Ty = {
    <TypeSub+> => Ty::Span(<>),
};

// TODO make a destructure type
Destructure: Ident = {
    Quote => Ident("$$$".to_string()),
    "(" <Destructure*> ")" => Ident("$$$".to_string()),
    "(" <Destructure*> "->" Destructure* ")" => Ident("$$$".to_string()),
    "[" Destructure* "]" => Ident("$$$".to_string()),
    <Ident> => <>,
    "!" Destructure => Ident("$$$".to_string()),
    ":" => Ident("$$$".to_string()),
    "==" => Ident("$$$".to_string()),
    "@" => Ident("$$$".to_string()),
    ">>=" => Ident("$$$".to_string()),
    "{" Comma<(Ident ("::" TypeSpan)?)> "}" => Ident("$$$".to_string()),
    "`" Ident "`" => Ident("$$$".to_string()),

    "," => Ident("$$$".to_string()), // TODO get rid of this

    "<" => Ident("$$$".to_string()), //Remove
    r"[0-9]+" => Ident("$$$".to_string()), //Remove
};

ImportList: () = {
    "(" Commaish<(Ident ("(" ".." ")")?)> ")" => (),
    "(" ")" => (),
    Ident => (),
};

pub Module: Module = {
  "module" Ident ("(" Comma<Section> ")")?
  "where" "{" <s:Semi<Statement>> "}" => Module {
    statements: s,
  },
};

Statement: Statement = {
  "class" Destructure+ ("=>" Ident+)?
    "where" "{" Semi<Statement> "}" => Statement::Class,

  "instance" FnDef "where"
    "{" Semi<Statement> "}" => Statement::Instance,
  "import" ImportList+ => Statement::Import,

  "data" <id:Ident+> "=" Pipe<Destructure+>
    ("deriving" ImportList)? =>
      Statement::Data(id[0].clone(), vec![], vec![]),
  "newtype" <id:Ident+> "=" <p:Destructure+>
    ("deriving" ImportList)? =>
      Statement::Newtype,

  <i:Ident> "::" <d:FnDef> => Statement::Prototype(i, vec![d]),

  "type" <d:Destructure> Destructure* "=" Expr+
    ("where" "{" Semi<Statement> "}")? => Statement::Typedef(d),

  Destructure Destructure* ("|" Commaish<Expr> "=" Expr+)*
    ("where" "{" Semi<Statement> "}")? => Statement::GuardAssign,

  <d:Destructure> <args:Destructure*> "=" <e:Expr+>
    ("where" "{" Semi<Statement> "}")? => Statement::Assign(d, args, e),
};

Tier<Op,NextTier>: Box<Expr> = {
    Tier<Op,NextTier> Op NextTier => Box::new(Expr::Op(<>)),
    NextTier
};

Arith = Tier<ExprOp, Factor>;
Factor = Tier<FactorOp, Term>;

ExprOp: Opcode = { // (3)
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

Term: Box<Expr> = {
    Num => Box::new(Expr::Number(<>)),
    "(" <Arith> ")",
    ! => { errors.push(<>); Box::new(Expr::Error) },
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};
