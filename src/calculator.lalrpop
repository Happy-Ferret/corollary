use std::str::FromStr;
use ast::{Expr, Opcode, Ident, Statement};
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, (usize, &'input str), ()>>);

pub Exprs = Comma<Expr>;

Dot<T>: Vec<T> = { // (0)
    <v:(<T> ".")+> <e:T> => { // (1)
        let mut v = v;
        v.push(e);
        v
    }
};

Semi<T>: Vec<T> = { // (0)
    <v:(<T> ";")*> <e:T?> => match e { // (1)
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Comma<T>: Vec<T> = { // (0)
    <v:(<T> ",")*> <e:T?> => match e { // (1)
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Pipe<T>: Vec<T> = { // (0)
    <v:(<T> "|")*> <e:T?> => match e { // (1)
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Commaish<T>: Vec<T> = { // (0)
    <(<T> ","?)+> => <>,
};

Ident: Ident = {
  r"[a-zA-Z_.][.a-zA-Z_0-9']*" => Ident((<>).to_string()),
};

Section: i32 = {
    Ident ("(" ".." ")")? => 0,
    Ident "(" Ident* ")" => 0,
    "module" Ident ("(" Comma<Section> ")")? => 0,
};

Case: () = {
    Destructure+ ("|" Commaish<Expr> "->" Expr+)* => (),
    Destructure+ "->" Expr+ => (),
};

Quote: () = {
    //r#"'\\["]'"# => (),
    r#"'[^']'"# => (),
    r#""[^"]*""# => (),
};

Expr: Statement = {
    Quote => Statement::Dummy,
    Ident => Statement::Dummy,
    "\(" Commaish<Ident> ")" "->" Expr => Statement::Dummy,
    "[" Commaish<Expr> "|" Expr+ "]" => Statement::Dummy,
    "[" Commaish<Expr> "]" => Statement::Dummy,
    "[" "]" => Statement::Dummy,
    "(" Commaish<Expr> ")" => Statement::Dummy,
    "(" ")" => Statement::Dummy,
    "(" "," ")" => Statement::Dummy,
    "(" FnDef "->" FnTerm+ ")" => Statement::Dummy,

    r"\\[a-zA-Z_.][.a-zA-Z_0-9']*" Expr* "->" Expr => Statement::Dummy,

    "\\" => Statement::Dummy,

    r"[0-9]+" => Statement::Dummy,

    "`" Ident "`" => Statement::Dummy,
    ":" => Statement::Dummy,
    "." => Statement::Dummy,
    "/=" => Statement::Dummy,
    "==" => Statement::Dummy,
    ".." => Statement::Dummy,
    "++" => Statement::Dummy,
    "$" => Statement::Dummy,
    "&&" => Statement::Dummy,
    "||" => Statement::Dummy,
    "<" => Statement::Dummy,
    "<=" => Statement::Dummy,
    "<-" => Statement::Dummy,
    ">" => Statement::Dummy,
    ">=" => Statement::Dummy,
    "=<<" => Statement::Dummy,
    ".|." => Statement::Dummy,
    ">>=" => Statement::Dummy,
    "@" => Statement::Dummy,
    "*" => Statement::Dummy,
    "+" => Statement::Dummy,
    "-" => Statement::Dummy,
    "^" => Statement::Dummy,
    "::" => Statement::Dummy,
    ".&." => Statement::Dummy,

    "case" Expr+ "of" "{" Semi<Case> "}" => Statement::Dummy,
    "let" "{" Semi<Data> "}" => Statement::Dummy,

    "do" "{" Semi<Expr+>
    ("where" "{" Semi<Data> "}")? "}" => Statement::Dummy,
    "{" Comma<(Ident "=" Expr+)> "}" => Statement::Dummy,
};

FnTerm: Statement = {
    Expr => Statement::Dummy,
};

FnDef: Statement = {
    FnDef "=>" FnTerm => Statement::Dummy,
    FnDef "->" FnTerm => Statement::Dummy,
    FnTerm => Statement::Dummy,
};

Type: () = {
    "!" Type => (),
    "[" Type+ "]" => (),
    "(" Commaish<Type> ")" => (),
    Ident "->" Ident => (),
    Ident => (),
    "(" ")" => (),
};

Destructure: () = {
    Quote => (),
    "(" <Destructure*> ")" => (),
    "[" Destructure* "]" => (),
    Ident => (),
    "," => (),
    "!" Destructure => (),
    ":" => (),
    "==" => (),
    "@" => (),
    ">>=" => (),
    "{" Comma<(Ident ("::" Type+)?)> "}" => (),
    "`" Ident "`" => (),

    "<" => (), //Remove
    r"[0-9]+" => (), //Remove
};

ImportList: () = {
    "(" Commaish<(Ident ("(" ".." ")")?)> ")" => (),
    "(" ")" => (),
    Ident => (),
};

Data: Statement = {
  "class" Destructure+ ("=>" Ident+)?
  "where" "{" Semi<Data> "}" => Statement::Dummy,

  "module" Ident ("(" Comma<Section> ")")?
  "where" "{" Semi<Data> "}" => Statement::Dummy,
  "instance" FnDef+ "where"
  "{" Semi<Data> "}" => Statement::Dummy,
  "{-#" Ident* "#-}" => Statement::Dummy,
  "import" ImportList+ => Statement::Dummy,

  "data" <id:Ident+> "=" Pipe<Destructure+>
  ("deriving" ImportList)? =>
    Statement::Data(id[0].clone(), vec![], vec![]),
  "newtype" <id:Ident+> "=" <p:Destructure+>
  ("deriving" ImportList)? =>
     Statement::Data(id[0].clone(), vec![], vec![]),

  Destructure+ ("|" Commaish<Expr> "=" Expr+)*
  ("where" "{" Semi<Data> "}")? => Statement::Dummy,

  Ident "::" FnDef+ => Statement::Dummy,
  Destructure+ "=" Expr+
  ("where" "{" Semi<Data> "}")? => Statement::Dummy,
};

pub Statements: Vec<Statement> = {
    Semi<Data> => <>,
};

Tier<Op,NextTier>: Box<Expr> = {
    Tier<Op,NextTier> Op NextTier => Box::new(Expr::Op(<>)),
    NextTier
};

Arith = Tier<ExprOp, Factor>;
Factor = Tier<FactorOp, Term>;

ExprOp: Opcode = { // (3)
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

Term: Box<Expr> = {
    Num => Box::new(Expr::Number(<>)),
    "(" <Arith> ")",
    ! => { errors.push(<>); Box::new(Expr::Error) },
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};
